[{"content":"题目 128. 最长连续序列\n官方题解\n方法一：哈希表 使用哈希表存储数组中的元素，然后对于每个元素，检查其前驱元素是否存在，以此来找到连续序列的起点，并计算序列长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_set\u0026lt;int\u0026gt; num_set; for (auto num : nums) { num_set.insert(num); } int res = 0; for (auto num : num_set) { if (!num_set.count(num - 1)) { int cur = num; int len = 1; while (num_set.count(cur + 1)) { len ++; cur ++; } res = max(res, len); } } return res; } }; ","date":"2026-01-05T13:17:12+08:00","permalink":"http://tech-ox.com/p/128.-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/","title":"128. 最长连续序列"},{"content":"题目 64. 最小路径和\n官方题解\n方法一：动态规划 使用二维数组 f[i][j] 表示从起点到位置 (i, j) 的最小路径和。状态转移方程为：\nf[0][0] = grid[0][0] f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j]（当 i \u0026gt; 0 且 j \u0026gt; 0 时） 边界情况：第一行和第一列只能从左或上累加。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(m, vector\u0026lt;int\u0026gt;(n)); for (int i = 0; i \u0026lt; m; i ++) for(int j = 0; j \u0026lt; n; j ++) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[0][0] = grid[0][0]; } else if (i == 0) { f[i][j] = f[i][j - 1] + grid[i][j]; } else if (j == 0) { f[i][j] = f[i - 1][j] + grid[i][j]; } else { f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; } } return f[m - 1][n - 1]; } }; 时间复杂度：O(m _ n)，空间复杂度：O(m _ n)。\n方法二：动态规划（空间优化） 由于每次计算只依赖上一行和当前行，可以用一维数组 f[j] 表示当前行的最小路径和。\n初始化第一行时，f[j] 累加左边值。 后续行：f[j] 先保存上一行的值，然后更新为 min(f[j], f[j-1]) + grid[i][j]。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = grid[0].size(); vector\u0026lt;int\u0026gt; f(n); for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[0] = grid[0][0]; } else if (i == 0) { f[j] = f[j - 1] + grid[i][j]; } else if (j == 0) { f[j] = f[j] + grid[i][j]; // f[j] 为上一行的 f[j] } else { f[j] = min(f[j], f[j - 1]) + grid[i][j]; // f[j] 为上一行的 f[j] } } } return f[n - 1]; } }; 时间复杂度：O(m * n)，空间复杂度：O(n)。\n","date":"2026-01-05T12:39:13+08:00","permalink":"http://tech-ox.com/p/64.-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","title":"64. 最小路径和"},{"content":"题目 32. 最长有效括号 官方题解\n方法一：栈 理解墙的概念，先向栈中加入一个-1的墙，每次匹配到右括号 ( 就弹栈一次，把左括号 ) 给弹出去，然后判断栈是否为空，因为有个 -1 的墙，如果栈空了，说明是没有匹配的左括号，就向栈中放新的墙来替代-1，这个墙永远在栈底这个位置，如果有新的墙产生，会先把这个栈底墙弹出去，有点设计的过于巧妙了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int longestValidParentheses(std::string s) { int res = 0; stack\u0026lt;int\u0026gt; stk; stk.push(-1); for (int i = 0; i \u0026lt; s.length(); ++i) { if (s[i] == \u0026#39;(\u0026#39;) { stk.push(i); } else { stk.pop(); if (stk.empty()) { stk.push(i); } else { res = max(res, i - stk.top()); } } } return res; } }; 方法二：动态规划 有点过于复杂了\ns[i] = \u0026lsquo;)\u0026rsquo; 且 s[i-1] = \u0026lsquo;(\u0026rsquo; 时，dp[i] = dp[i-2] + 2 s[i] = \u0026lsquo;)\u0026rsquo; 且 s[i-1] = \u0026lsquo;)\u0026rsquo; 时，若 s[i-dp[i-1]-1] = \u0026lsquo;(\u0026rsquo;，则 dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2 还要注意俩个边界条件要排除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int longestValidParentheses(string s) { int maxans = 0, n = s.length(); vector\u0026lt;int\u0026gt; dp(n, 0); for (int i = 1; i \u0026lt; n; i++) { if (s[i] == \u0026#39;)\u0026#39;) { if (s[i - 1] == \u0026#39;(\u0026#39;) { dp[i] = (i \u0026gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] \u0026gt; 0 \u0026amp;\u0026amp; s[i - dp[i - 1] - 1] == \u0026#39;(\u0026#39;) { dp[i] = dp[i - 1] + ((i - dp[i - 1]) \u0026gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = max(maxans, dp[i]); } } return maxans; } }; ","date":"2026-01-05T10:39:13+08:00","permalink":"http://tech-ox.com/p/32.-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","title":"32. 最长有效括号"},{"content":"题目 538. 把二叉搜索树转换为累加树 官方题解\n方法一：反向中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int sum; TreeNode* convertBST(TreeNode* root) { if (root != nullptr) { convertBST(root-\u0026gt;right); sum += root-\u0026gt;val; root-\u0026gt;val = sum; convertBST(root-\u0026gt;left); } return root; } }; ","date":"2026-01-05T09:24:31+08:00","permalink":"http://tech-ox.com/p/538.-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/","title":"538. 把二叉搜索树转换为累加树"},{"content":"题目 338. 比特位计数 官方题解\n方法一：逐位计数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int countB(int i) { int cnt = 0; while (i) { cnt += i \u0026amp; 1; i = i \u0026gt;\u0026gt; 1; } return cnt; } vector\u0026lt;int\u0026gt; countBits(int n) { vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt;= n; i ++) { res.push_back(countB(i)); } return res; } }; 方法二：动态规划——最低有效位 $$ f[i] = f[i \u003e\u003e 1] + (i \\\u0026 1) $$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: vector\u0026lt;int\u0026gt; countBits(int n) { vector\u0026lt;int\u0026gt; res; res.push_back(0); for (int i = 1; i \u0026lt;= n; i ++) { res.push_back(res[i \u0026gt;\u0026gt; 1] + (i \u0026amp; 1)); } return res; } }; 方法三：动态规划——最高有效位 $$ (i \u0026 (i - 1)) == 0 f[i] = f[i - highBit] + 1 $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: vector\u0026lt;int\u0026gt; countBits(int n) { vector\u0026lt;int\u0026gt; bits(n + 1); int highBit = 0; for (int i = 1; i \u0026lt;= n; i++) { if ((i \u0026amp; (i - 1)) == 0) { highBit = i; } bits[i] = bits[i - highBit] + 1; } return bits; } }; ","date":"2026-01-05T09:05:34+08:00","permalink":"http://tech-ox.com/p/338.-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/","title":"338. 比特位计数"},{"content":"题目 240. 搜索二维矩阵 II 官方题解\n方法一：从右上角开始搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { if (matrix.size() == 0 || matrix[0].size() == 0) return false; int rows = matrix.size(), columns = matrix[0].size(); // 从右上角(0, columns)-\u0026gt;(rows, 0) // 如果小于就target就下移，大于左移 int x = 0, y = columns - 1; while (x \u0026lt; rows \u0026amp;\u0026amp; y \u0026gt;= 0) { if (matrix[x][y] \u0026lt; target) { x ++; } else if (matrix[x][y] \u0026gt; target) { y --; } else { return true; } } return false; } }; 时间复杂度\nO(m + n)，m 和 n 分别是矩阵的行数和列数。\n方法二：爆搜 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target, int x, int y) { if (x \u0026gt;= matrix.size() || y \u0026gt;= matrix[0].size()) { return false; } if (matrix[x][y] == target) { return true; } else if (matrix[x][y] \u0026lt; target) { return dfs(matrix, target, x + 1, y) || dfs(matrix, target, x, y +1); } else { return false; } } bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { return dfs(matrix, target, 0, 0); } }; 时间复杂度\nO(2^(m+n))，m 和 n 分别是矩阵的行数和列数。\n117 / 130 个通过的测试用例\n","date":"2026-01-04T14:24:40+08:00","permalink":"http://tech-ox.com/p/240.-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/","title":"240. 搜索二维矩阵 II"},{"content":"题目 85. 最大矩形 官方题解\n刚开始想了一个暴力的解法，但是理解错误题目意思了，是矩形不是正方形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool isTrue(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix, int i, int j, int size) { for (int x = i; x \u0026lt; i + size; x ++) { for (int y = j; y \u0026lt; j + size; y ++) { if (matrix[x][y] == \u0026#39;0\u0026#39;) return false; } } return true; } int maximalSquare(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { int max_size = min(matrix.size(), matrix[0].size()); for (int i = max_size; i \u0026gt; 0; i --) { for (int j = 0; j + i \u0026lt;= matrix.size(); j ++) { for (int k = 0; k + i \u0026lt;= matrix[0].size(); k ++) { // 判断是否 if (isTrue(matrix, j, k, i)) return i * i; } } } return 0; } }; 时间复杂度\nO((mn)^2)，m 和 n 分别是矩阵的行数和列数。\n实际上是原题 221. 最大正方形\n动态规划写法\n$$ dp(i,j)=\\min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1 $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int maximalSquare(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) { return 0; } int maxSide = 0; int rows = matrix.size(), columns = matrix[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(rows, vector\u0026lt;int\u0026gt;(columns)); for (int i = 0; i \u0026lt; rows; i ++) { for (int j = 0; j \u0026lt; columns; j ++) { if (matrix[i][j] == \u0026#39;1\u0026#39;) { if (i == 0 || j == 0) { dp[i][j] = 1; } else { dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; } maxSide = max(maxSide, dp[i][j]); } } } return maxSide * maxSide; } }; 回到原题 暴力枚举\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: bool isTrue(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix, int i, int j, int x, int y) { // 判断 (i, j) (x, y) 矩形 for (int k = i; k \u0026lt;= x; k ++) { for (int l = j; l \u0026lt;= y; l ++) { if (matrix[k][l] == \u0026#39;0\u0026#39;) { return false; } } } return true; } int maximalRectangle(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) return 0; int rows = matrix.size(), columns = matrix[0].size(); int maxSize = 0; for (int i = 0; i \u0026lt; rows; i ++) for (int j = 0; j \u0026lt; columns; j ++) if (matrix[i][j] == \u0026#39;1\u0026#39;) { // 枚举右下角坐标 for (int x = i; x \u0026lt; rows; x ++) { for (int y = j; y \u0026lt; columns; y ++ ) { if (isTrue(matrix, i, j, x, y)) { maxSize = max(maxSize, (x - i + 1) * (y - j + 1)); } } } } return maxSize; } }; 时间复杂度\nO((mn)^3)，m 和 n 分别是矩阵的行数和列数。\n70/75 TLE\n暴力优化 我们首先计算出矩阵的每个元素的左边连续 1 的数量，使用二维数组 left 记录，其中 left[i][j] 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: int maximalRectangle(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) return 0; int rows = matrix.size(), columns = matrix[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; left(rows, vector\u0026lt;int\u0026gt;(columns)); for (int i = 0; i \u0026lt; rows; i ++) { for (int j = 0; j \u0026lt; columns; j ++) { // 判断(i, j) 左侧有多少个连续的1 if (matrix[i][j] == \u0026#39;1\u0026#39;) { left[i][j] = (j == 0 ? 1 : left[i][j - 1] + 1); } } } int ret = 0; for (int i = 0; i \u0026lt; rows; i ++) { for (int j = 0; j \u0026lt; columns; j ++) { if (matrix[i][j] == \u0026#39;0\u0026#39;) { continue; } int width = left[i][j]; int area = width; for (int k = i - 1; k \u0026gt;= 0; k --) { width = min(width, left[k][j]); area = max(area, width * (i - k + 1)); } ret = max(ret, area); } } return ret; } }; 还是动态规划，提示标签里有单调栈，先放一放\n","date":"2026-01-04T10:37:02+08:00","permalink":"http://tech-ox.com/p/85.-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","title":"85. 最大矩形"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://tech-ox.com/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_9e6bcf9cfe9a9448.jpg","permalink":"http://tech-ox.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://tech-ox.com/p/math-typesetting/","title":"Math Typesetting"}]