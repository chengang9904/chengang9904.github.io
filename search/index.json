[{"content":"题目 39. 组合总和 官方题解\n方法一：回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; void dfs(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target, int u, vector\u0026lt;int\u0026gt; tmp) { if (target == 0) { res.push_back(tmp); return; } if (target \u0026lt; 0) return; if (u == candidates.size()) return; // fang tmp.push_back(candidates[u]); dfs(candidates, target - candidates[u], u, tmp); tmp.pop_back(); dfs(candidates, target, u + 1, tmp); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { dfs(candidates, target, 0, vector\u0026lt;int\u0026gt;()); return res; } }; 时间复杂度：O(N^(T/M + 1))，其中 N 是候选数组的长度，T 是目标值，M 是候选数组中的最小值。最坏情况下，递归树的高度为 T/M，每一层有 N 个分支。 空间复杂度：O(T/M)，递归调用栈的空间取决于递归树的高度，即 T/M。\n优化 vector tmp 改为类成员变量，避免每次递归时传递和复制 tmp，从而节省空间和时间开销。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; tmp; void dfs(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target, int u) { if (target == 0) { res.push_back(tmp); return; } if (u == candidates.size()) return; dfs(candidates, target, u + 1); // fang if (target - candidates[u] \u0026gt;= 0) { tmp.push_back(candidates[u]); dfs(candidates, target - candidates[u], u); tmp.pop_back(); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { dfs(candidates, target, 0); return res; } }; ","date":"2026-01-09T09:54:04+08:00","permalink":"http://tech-ox.com/p/39.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","title":"39. 组合总和"},{"content":"题目 617. 合并二叉树 官方题解\n方法一：递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if (!root1 \u0026amp;\u0026amp; !root2) return nullptr; if (!root1) return root2; if (!root2) return root1; root1-\u0026gt;val = root1-\u0026gt;val + root2-\u0026gt;val; root1-\u0026gt;left = mergeTrees(root1-\u0026gt;left, root2-\u0026gt;left); root1-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); return root1; } }; 时间复杂度：O(min(M, N))，其中 M 和 N 分别是两棵二叉树的节点数。需要遍历的节点数取决于较小的那棵树。 空间复杂度：O(min(H1, H2))，其中 H1 和 H2 分别是两棵二叉树的高度。递归调用栈的空间取决于较小的那棵树的高度。\n","date":"2026-01-09T09:24:57+08:00","permalink":"http://tech-ox.com/p/617.-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"617. 合并二叉树"},{"content":"题目 437. 路径总和 III 官方题解\n方法1：自己写的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int res; void dfs(TreeNode* root, bool flag, int sum, int targetSum) { if (!root) { return; } if (flag) { if (sum + root-\u0026gt;val == targetSum) res ++; dfs(root-\u0026gt;left, true, sum + root-\u0026gt;val, targetSum); dfs(root-\u0026gt;right, true, sum + root-\u0026gt;val, targetSum); } else { if (root-\u0026gt;val == targetSum) res ++; dfs(root-\u0026gt;left, true, root-\u0026gt;val, targetSum); dfs(root-\u0026gt;left, false, 0, targetSum); dfs(root-\u0026gt;right, true, root-\u0026gt;val, targetSum); dfs(root-\u0026gt;right, false, 0, targetSum); } } int pathSum(TreeNode* root, int targetSum) { dfs(root, false, 0, targetSum); return res; } }; 时间复杂度：O(n^2)，n为节点数\n空间复杂度：O(h)，h为树的高度\n127/130 test cases passed.\n","date":"2026-01-08T20:27:02+08:00","permalink":"http://tech-ox.com/p/437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/","title":"437. 路径总和 III"},{"content":"题目 139. 单词拆分 官方题解\n方法1：暴搜 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: bool dfs(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict, int u) { if (u == s.size()) { return true; } for (int i = 0; i \u0026lt; wordDict.size(); i ++) { // 判断是否满足条件 bool flag = true; for (int j = 0; j \u0026lt; wordDict[i].size(); j ++) { if (u + j \u0026lt; s.size()) { if (s[u + j] != wordDict[i][j]) { cout \u0026lt;\u0026lt; wordDict[i] \u0026lt;\u0026lt; endl;; flag = false; break; } } } if (flag) { if (dfs(s, wordDict, u + wordDict[i].size())) return true;; } } return false; } bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { return dfs(s, wordDict, 0); } }; 时间复杂度：O(m^n)，m为字典中单词的平均长度，n为字符串s的长度\n空间复杂度：O(n)\n方法2：动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { unordered_set\u0026lt;string\u0026gt; wordset; for (auto t : wordDict) { wordset.insert(t); } vector\u0026lt;bool\u0026gt; dp(s.size() + 1); dp[0] = true; for (int i = 1; i \u0026lt;= s.size(); i ++) { for (int j = 0; j \u0026lt; i; j ++) { if (dp[j] \u0026amp;\u0026amp; wordset.find(s.substr(j, i - j)) != wordset.end()) { dp[i] = true; break; } } } return dp[s.size()]; } }; 时间复杂度：O(n^2)\n空间复杂度：O(n)\n","date":"2026-01-08T13:04:17+08:00","permalink":"http://tech-ox.com/p/139.-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","title":"139. 单词拆分"},{"content":"题目 48. 旋转图像 官方题解\n方法一：转置 + 翻转 矩阵的转置是将矩阵的行列互换，即将元素 matrix[i][j] 变为 matrix[j][i]。翻转是将矩阵的每一行进行反转操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); // 水平翻转 for (int i = 0; i \u0026lt; n / 2; ++i) { for (int j = 0; j \u0026lt; n; ++j) { swap(matrix[i][j], matrix[n - i - 1][j]); } } // 主对角线翻转 for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { swap(matrix[i][j], matrix[j][i]); } } } }; 方法二：四个一组交换 将矩阵分成四个一组进行交换，每次交换四个元素的位置，从外层向内层进行，直到处理完所有的层。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); for (int i = 0; i \u0026lt; n / 2; ++i) { for (int j = 0; j \u0026lt; (n + 1) / 2; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; } } } }; ","date":"2026-01-07T11:03:59+08:00","permalink":"http://tech-ox.com/p/48.-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","title":"48. 旋转图像"},{"content":"题目 78. 子集\n官方题解\n方法1：回溯 刚开始写错了，写了个带长度的全排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; void dfs(vector\u0026lt;int\u0026gt; nums, int u, int length, vector\u0026lt;int\u0026gt; tmp, bool st[]) { if (u == length) { res.push_back(tmp); } for (int i = 0; i \u0026lt; nums.size(); i ++) { if (!st[i]) { st[i] = true; tmp.push_back(nums[i]); dfs(nums, u + 1, length, tmp, st); st[i] = false; tmp.pop_back(); } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); bool st[n]; vector\u0026lt;int\u0026gt; tmp; for (int i = 0; i \u0026lt;= n; i ++) { memset(st, false, sizeof st); tmp.clear(); dfs(nums, 0, i, tmp, st); } return res; } }; 正确代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; void dfs(vector\u0026lt;int\u0026gt; nums, int u, int length, vector\u0026lt;int\u0026gt; tmp) { if (tmp.size() == length) { res.push_back(tmp); return; } if (u == nums.size()) { return ; } // put tmp.push_back(nums[u]); dfs(nums, u + 1, length, tmp); tmp.pop_back(); // not put dfs(nums, u + 1, length, tmp); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); bool st[n]; vector\u0026lt;int\u0026gt; tmp; for (int i = 0; i \u0026lt;= n; i ++) { tmp.clear(); dfs(nums, 0, i, tmp); } return res; } }; 时间复杂度：O(N * 2^N) 空间复杂度：O(N)\n因为我是在之前的排列代码上改的，所以其实并不需要用到length参数，可以直接在dfs里把结果加入res\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; tmp; void dfs(vector\u0026lt;int\u0026gt; nums, int u) { if (u == nums.size()) { res.push_back(tmp); return; } dfs(nums, u + 1); tmp.push_back(nums[u]); dfs(nums, u + 1); tmp.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); dfs(nums, 0); return res; } }; 时间复杂度：O(N * 2^N) 空间复杂度：O(N)\n方法2：最简洁的子集模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; void dfs(vector\u0026lt;int\u0026gt; nums, int u) { res.push_back(tmp); for (int i = u; i \u0026lt; nums.size(); i ++) { tmp.push_back(nums[i]); dfs(nums, i + 1); tmp.pop_back(); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { dfs(nums, 0); return res; } }; 时间复杂度：O(N * 2^N) 空间复杂度：O(N)\n方法3：位运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask ++) { vector\u0026lt;int\u0026gt; tmp; for (int i = 0; i \u0026lt; n; i ++) { if (mask \u0026amp; (1 \u0026lt;\u0026lt; i)) { tmp.push_back(nums[i]); } } res.push_back(tmp); } return res; } }; 时间复杂度：O(N * 2^N) 空间复杂度：O(N)\n小结 本题有三种常见解法，回溯、位运算和迭代法（见官方题解）。\n","date":"2026-01-06T11:39:48+08:00","permalink":"http://tech-ox.com/p/78.-%E5%AD%90%E9%9B%86/","title":"78. 子集"},{"content":"题目 10. 正则表达式匹配\n官方题解\n方法1：动态规划 详见官方题解。\n状态转移方程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: bool matches(string s, string p, int i, int j) { if (i == 0) return false; if (p[j - 1] == \u0026#39;.\u0026#39;) return true; return s[i - 1] == p[j - 1]; } bool isMatch(string s, string p) { int m = s.size(), n = p.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(m +1, vector\u0026lt;int\u0026gt;(n +1)); f[0][0] = true; for (int i = 0; i \u0026lt;= m; i ++) { for (int j = 1; j \u0026lt;= n; j ++) { if (p[j - 1] == \u0026#39;*\u0026#39;) { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] |= f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } }; 小结 好难，好难啊！\n","date":"2026-01-06T10:17:24+08:00","permalink":"http://tech-ox.com/p/10.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","title":"10. 正则表达式匹配"},{"content":"题目 207. 课程表\n官方题解\n复习拓扑排序 Acwing 基础课模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], e[N], ne[N], idx; int d[N]; int q[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool topsort() { int hh = 0, tt = -1; for (int i = 1; i \u0026lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh \u0026lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } return tt == n - 1; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(h, -1, sizeof h); for (int i = 0; i \u0026lt; m; i ++ ) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); d[b] ++ ; } if (!topsort()) puts(\u0026#34;-1\u0026#34;); else { for (int i = 0; i \u0026lt; n; i ++ ) printf(\u0026#34;%d \u0026#34;, q[i]); puts(\u0026#34;\u0026#34;); } return 0; } 方法一：拓扑排序（Kahn算法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: static const int N = 2010, M = 5010; int e[M], ne[M], h[N], idx; int d[N], q[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { memset(h, -1, sizeof h); for (int i = 0; i \u0026lt; prerequisites.size(); i ++) { int a = prerequisites[i][0], b = prerequisites[i][1]; add(a, b); d[b] ++; } int hh = 0, tt = -1; for (int i = 0; i \u0026lt; numCourses; i ++) { if (!d[i]) { q[++ tt] = i; } } while (hh \u0026lt;= tt) { auto t = q[hh ++]; for (int i = h[t]; ~i; i = ne[i]) { auto j = e[i]; d[j] --; if (!d[j]) { q[++ tt] = j; } } } return numCourses - 1 == tt; } }; ","date":"2026-01-06T09:19:39+08:00","permalink":"http://tech-ox.com/p/207.-%E8%AF%BE%E7%A8%8B%E8%A1%A8/","title":"207. 课程表"},{"content":" Git 作为现代版本控制系统的基石，其强大的分支管理能力为团队协作带来了前所未有的灵活性。然而，如何有效地利用这些分支，组织团队的开发流程，却是许多团队面临的挑战。本文将深入探讨三种最流行的 Git 开发工作流：Git Flow、GitHub Flow，以及开源社区广泛采用的 Forking Workflow，帮助你理解它们的特点、适用场景及具体操作。\n1. Git Flow：结构严谨，适用于有稳定发布周期的产品 Git Flow 是由 Vincent Driessen 提出的一个严格且定义清晰的分支模型。它为不同阶段的开发任务分配了特定的分支类型，旨在保证发布版本的稳定性和可控性。\n图片来源: nvie.com\n核心分支类型 master (主分支)：始终代表生产环境中稳定、可发布的版本。 develop (开发分支)：所有新功能的集成点，包含下一个版本的所有已开发功能。 feature (功能分支)：从 develop 创建，用于开发独立的新功能。完成后合并回 develop。 release (发布分支)：从 develop 创建，用于准备发布。在此分支上进行 Bug 修复、版本号更新、测试等，完成后合并到 master 和 develop。 hotfix (热补丁分支)：从 master 创建，用于紧急修复生产环境 Bug。修复完成后，合并到 master 和 develop。 工作流示例 初始化：\nmaster 和 develop 分支是项目开始时的两个长期分支。 新功能开发：\n开发者从 develop 分支创建 feature/your-feature-name。 在此分支上进行开发和提交。 功能完成后，通过 Pull Request/Merge Request 合并回 develop，并删除 feature 分支。 准备发布：\n当 develop 分支积累了足够的功能，准备发布新版本时，从 develop 创建 release/vX.Y.Z 分支。 在此分支上进行最后的 Bug 修复、测试、版本号更新。 测试通过后，将 release 分支合并到 master (打上版本 Tag) 和 develop (同步改动)，然后删除 release 分支。 紧急修复 (Hotfix)：\n当生产环境发现紧急 Bug 时，从 master 创建 hotfix/fix-bug-name 分支。 在此分支上进行修复。 修复完成后，将 hotfix 分支合并到 master (打上新版本 Tag) 和 develop (同步改动)，然后删除 hotfix 分支。 优点 结构清晰：各分支职责明确，易于理解和管理。 发布稳定：release 分支为发布提供了独立的测试和 Bug 修复阶段，保证了 master 分支的稳定性。 版本控制严谨：适合有明确发布周期、需要严格控制版本的项目。 缺点 流程复杂：分支类型多，操作相对繁琐，对团队有一定学习成本。 发布周期长：release 分支的引入可能拉长发布周期，不适合快速迭代。 潜在合并冲突：在 release 分支完成后，需要合并到 master 和 develop 两次，增加了处理合并冲突的负担。 2. GitHub Flow：简洁高效，适用于持续集成/持续交付 GitHub Flow 是一种更轻量、更简单、更灵活的工作流，由 GitHub 推广。它的核心思想是：master 分支永远是可部署的。\n核心分支类型 master (主分支)：始终代表可部署到生产环境的代码。 feature (功能/修复分支)：从 master 创建，用于开发新功能或修复 Bug。开发完成后，通过 Pull Request 合并回 master。 工作流示例 初始化：\n只有一个 master 分支，它是项目的起点。 开发任何任务：\n无论是新功能、Bug 修复、还是文档更新，都从 master 分支创建新的功能分支，例如 add-user-profile 或 fix-login-bug。 在此分支上进行开发和提交。 关键： 在此分支上，要经常从 master 拉取最新代码 (通过 merge 或 rebase)，保持与 master 的同步。 发起 Pull Request：\n功能开发完成后，将分支推送到远程仓库。 在 GitHub 上发起 Pull Request (PR)，请求将此功能分支合并到 master。 PR 会触发自动化测试 (CI/CD)，并由团队成员进行代码审查。 合并与部署：\n审查通过，所有自动化检查通过后，将 PR 合并到 master。 关键： 每次合并到 master，都应自动触发部署到测试环境，甚至直接部署到生产环境 (如果配置了持续部署)。 合并后，删除功能分支。 优点 简单直观：只有 master 和功能分支，流程易于理解和上手。 持续集成/持续交付 (CI/CD) 友好：每次合并到 master 都可以触发自动化测试和部署，非常适合快速迭代和频繁发布。 快速迭代：减少了分支管理的开销，发布周期短。 减少合并冲突：由于功能分支生命周期短，并且经常与 master 同步，冲突相对较少。 缺点 对自动化测试要求高：由于 master 必须始终可部署，强大的自动化测试套件和 CI/CD 流程是必要条件。 潜在生产风险：如果自动化测试不充分，直接合并到 master 并部署可能带来风险。 版本管理不明确：没有 release 分支进行版本固化，版本发布主要依赖于 master 分支上的 Tag。 3. Forking Workflow：开放协作，适用于开源项目和外部贡献 Forking Workflow (或称 Fork + Pull Request 工作流) 是 GitHub 等代码托管平台上的标准开源项目协作模式。它通过“复制”仓库的方式，允许任何外部贡献者安全地参与项目，而无需直接写入主仓库的权限。\n核心概念 主仓库 (Upstream Repository)：项目的原始仓库，由核心维护者控制。 个人副本 (Fork)：贡献者在自己 GitHub 账号下创建的主仓库的完整副本。 Pull Request (PR)：贡献者请求将自己 Fork 上的改动合并到主仓库的机制。 工作流示例 假设你 (贡献者 Alice) 想为开源项目 AwesomeProject/AwesomeRepo 提交一个 Bug 修复。\nFork 主仓库：\nAlice 访问 AwesomeProject/AwesomeRepo 的 GitHub 页面，点击 \u0026ldquo;Fork\u0026rdquo; 按钮。 GitHub 会在 Alice 的账号下创建一个副本，例如 Alice/AwesomeRepo。 克隆 Fork 到本地并设置上游：\nAlice 克隆她自己的 Fork：git clone https://github.com/Alice/AwesomeRepo.git 进入项目目录：cd AwesomeRepo 添加主仓库为上游远程仓库：git remote add upstream https://github.com/AwesomeProject/AwesomeRepo.git 同步主仓库最新代码 (重要)：\n定期从上游仓库拉取最新改动，保持本地 master (或 main) 分支与主仓库同步： 1 2 3 git fetch upstream git checkout master git merge upstream/master # 或者 git rebase upstream/master 创建功能/修复分支：\n从本地 master 创建新的分支，用于开发任务：git checkout -b bugfix/fix-some-issue 开发与提交：\nAlice 在 bugfix/fix-some-issue 分支上进行开发，并多次提交。 推送到自己的 Fork：\n开发完成后，将新分支推送到 Alice 自己的远程 Fork：git push origin bugfix/fix-some-issue 发起 Pull Request (PR)：\nAlice 访问她自己的 Fork (Alice/AwesomeRepo) 在 GitHub 上的页面。 GitHub 通常会提示 \u0026ldquo;Compare \u0026amp; pull request\u0026rdquo;。 Alice 创建 PR，目标设置为 AwesomeProject/AwesomeRepo 的 master (或指定开发分支)，源是她自己的 bugfix/fix-some-issue 分支。 填写 PR 标题和描述。 代码审查与合并：\nAwesomeProject 的核心维护者会审查 Alice 的 PR。 可能提出修改意见，Alice 在其本地分支上修改并重新推送，PR 会自动更新。 审查通过后，维护者将 PR 合并到主仓库的 master 分支。 清理：\nPR 合并后，Alice 可以删除本地和远程的功能分支。 优点 权限隔离：贡献者无需主仓库的写入权限，降低了主仓库的风险。 开放协作：鼓励社区广泛参与，任何人都可以自由贡献。 流程规范化：Pull Request 机制强制了代码审查，确保了贡献的质量。 灵活性：贡献者可以在自己的 Fork 上进行任何实验，而不会影响主仓库。 缺点 管理多个远程仓库：需要额外管理 origin (自己的 Fork) 和 upstream (主仓库) 两个远程仓库。 同步上游负担：贡献者需要定期同步上游主仓库的最新改动，以避免大的合并冲突。 如何选择适合你的工作流？ 选择 Git Flow：如果你管理的是一个大型、复杂的软件产品，有明确且不那么频繁的发布周期 (例如，每月或每季度发布)，并且对生产环境的稳定性有极高的要求，Git Flow 能为你提供严谨的控制和可预测性。\n选择 GitHub Flow：如果你追求快速迭代、持续交付，项目更新频繁，并且有强大的自动化测试和 CI/CD 基础设施做支撑，GitHub Flow 将是更高效、更灵活的选择。它非常适合 Web 应用、SaaS 产品和微服务。\n在开源项目或接受外部贡献时，选择 Forking Workflow：这是 GitHub 上进行开放协作的标准模式，它在保证主仓库安全的同时，最大限度地鼓励了社区贡献。\n混合模式：许多企业和大型项目会结合这几种模式的优点。例如，内部团队可能采用 GitHub Flow 进行日常开发，但当需要对外发布一个重要版本时，会临时从 master 拉出一个短暂的 release 分支进行更严格的测试和 UAT，这类似于 Git Flow 的 release 阶段。而当有外部贡献者参与时，则自然会使用 Forking Workflow。\n总结 没有“放之四海而皆准”的最佳工作流，最重要的是根据你团队的规模、项目的特点、发布节奏和对稳定性的要求来选择或定制最合适的 Git 工作流。无论选择哪种，代码审查 (Pull Request/Merge Request) 和 持续集成 (CI/CD) 都是提升团队协作效率和代码质量的关键实践。\n","date":"2026-01-05T21:58:00+08:00","permalink":"http://tech-ox.com/p/git-%E4%B8%89%E5%A4%A7%E4%B8%BB%E6%B5%81%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%8E%E4%BC%A0%E7%BB%9F%E5%88%B0%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","title":"Git 三大主流开发工作流：从传统到现代的最佳实践"},{"content":"前言 本文是《Vue.js 从入门到实战》视频课程的配套文章，课程详细讲解了如何使用 Vue.js 框架开发一个完整的 TodoMVC 应用。如果你更喜欢视频学习，可以点击下面的链接观看完整课程： 视频课程\n项目介绍 TodoMVC 是一个经典的前端示例项目，旨在展示各种前端框架和库如何实现相同的功能。通过构建一个简单的待办事项应用，开发者可以比较不同技术栈的优缺点，并学习最佳实践。\n搭建vue 在开始编码之前，我们需要确保已经安装了 Node.js 和 Vue CLI。如果还没有安装，可以参考以下步骤：\n安装 Node.js：访问 Node.js 官网 下载并安装最新的 LTS 版本。\n安装 Vue CLI：打开终端或命令提示符，运行以下命令安装 Vue CLI：\n1 npm install -g @vue/cli 创建 Vue 项目：运行以下命令创建一个新的 Vue 项目：\n1 npm create vue@2 选择项目配置：在提示中选择默认配置，等待项目创建完成。\n进入项目目录：运行以下命令进入项目目录：\n1 2 cd your-project-name npm install 启动开发服务器：运行以下命令启动开发服务器：\n1 npm run serve 现在，你已经成功搭建了一个 Vue.js 项目，接下来我们将开始构建 TodoMVC 应用的各个部分。\n项目结构 在开始编码之前，我们先了解一下项目的基本结构。一个典型的 Vue.js 项目包含以下几个主要目录和文件：\n1 2 3 4 5 6 7 8 9 10 your-project-name/ ├── public/ # 静态资源文件夹 │ └── index.html # 入口 HTML 文件 ├── src/ # 源代码文件夹 │ ├── assets/ # 静态资源（图片、样式等） │ ├── components/ # Vue 组件文件夹 │ ├── App.vue # 根组件 │ └── main.js # 入口 JavaScript 文件 ├── package.json # 项目配置文件 └── README.md # 项目说明文件 拷贝模板 为了节省时间，我们可以直接使用现成的 TodoMVC Vue 模板。你可以从 [TodoMVC GitHub 仓库](https://github.com/tastejs/todomvc-app-template）下载 Vue 版本的模板，或者使用以下命令克隆仓库：\n1 git clone git@github.com:tastejs/todomvc-app-template.git 我们只拷贝 index.html 中我们需要的部分，然后样式通过链接导入\ncss 文件通过链接导入\n1 @import \u0026#39;https://unpkg.com/todomvc-app-css@2.4.1/index.css\u0026#39;; 然后删掉script中的内容\n在main.js 中删掉css的导入\n最后搂一眼，差不多就是基础的样式搭建好了\n编写代码 首先需要一个响应式的数据结构来存储待办事项列表。我们可以在 Vue 组件的 data 选项中定义一个数组来保存待办事项。\n编写模拟的数据 1 2 3 4 5 6 7 8 data() { return { todos: [ { id: 1, title: \u0026#39;学习 Vue.js\u0026#39;, completed: true }, { id: 2, title: \u0026#39;构建 TodoMVC 应用\u0026#39;, completed: false }, ], }; } 渲染待办事项列表 找到标签，使用v-for指令遍历todos数组，动态生成待办事项列表。\n1 \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34; :class=\u0026#34;{ completed: todo.completed }\u0026#34;\u0026gt; 绑定待办事项数据 使用v-model指令实现双向绑定。\nlabel标签中显示待办事项的标题，可以用插值表达式来显示todo.title，也可以使用v-text指令。\n1 2 3 4 5 \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;todo.completed\u0026#34;\u0026gt; \u0026lt;label\u0026gt;{{ todo.title }}\u0026lt;/label\u0026gt; \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ToggleAll 实现全选和取消全选功能。我们可以使用计算属性来判断是否所有待办事项都已完成，并通过一个方法来切换所有待办事项的状态。\n1 2 3 4 5 toggleAll(e) { this.todos.forEach(todo =\u0026gt; { todo.completed = e.target.checked; }); }, 过滤 实现待办事项的过滤功能。我们可以使用计算属性来根据当前的过滤条件返回不同的待办事项列表。\n添加一个visibility属性来存储当前的过滤条件：\n添加mounted钩子来监听hash变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 methods: { onHashChange() { const hash = window.location.hash.replace(/#\\/?/, \u0026#39;\u0026#39;) if ([\u0026#39;all\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;completed\u0026#39;].includes(hash)) { this.visibility = hash } else { window.location.hash = \u0026#39;\u0026#39; this.visibility = \u0026#39;all\u0026#39; } }, }, mounted() { window.addEventListener(\u0026#39;hashchange\u0026#39;, this.onHashChange); this.onHashChange(); } 然后使用计算属性filteredTodos来根据visibility属性过滤待办事项：\n1 2 3 4 5 6 7 8 9 10 11 computed: { filteredTodos() { if (this.visibility === \u0026#39;all\u0026#39;) { return this.todos; } else if (this.visibility === \u0026#39;active\u0026#39;) { return this.todos.filter(todo =\u0026gt; !todo.completed); } else if (this.visibility === \u0026#39;completed\u0026#39;) { return this.todos.filter(todo =\u0026gt; todo.completed); } }, } 最后，在模板中使用filteredTodos来渲染待办事项列表：\n计算未完成事项数 我们可以使用计算属性来计算未完成事项的数量：\n1 2 3 4 5 computed: { remaining() { return this.todos.filter(todo =\u0026gt; !todo.completed).length; }, } 然后在模板中显示未完成事项数：\n清除已完成事项 我们可以添加一个方法来清除所有已完成的待办事项：\n1 2 3 4 5 methods: { clearCompleted() { this.todos = this.todos.filter(todo =\u0026gt; !todo.completed); }, } 然后在模板中绑定点击事件：\n新增删除待办事项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 methods: { addTodo(e) { const title = e.target.value.trim(); if (title) { this.todos.push({ id: this.todos.length + 1, title, completed: false }); e.target.value = \u0026#39;\u0026#39;; } }, removeTodo(todo) { this.todos = this.todos.filter(t =\u0026gt; t.id !== todo.id); }, } 移除已完成事项 1 2 3 clearCompleted() { this.todos = this.todos.filter(todo =\u0026gt; !todo.completed); } 细节处理 items-left 显示未完成事项数，使用计算属性 remaining 来动态计算未完成事项的数量。\n1 2 3 4 5 computed: { remaining() { return this.todos.filter(todo =\u0026gt; !todo.completed).length; }, } 然后在模板中显示未完成事项数：\n1 2 3 \u0026lt;span class=\u0026#34;todo-count\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;{{ remaining }}\u0026lt;/strong\u0026gt; item{{ remaining !== 1 ? \u0026#39;s\u0026#39; : \u0026#39;\u0026#39; }} left \u0026lt;/span\u0026gt; 如果没有待办事项时，隐藏底部栏和待办事项列表，可以使用 v-if 指令来实现：\n1 \u0026lt;footer class=\u0026#34;footer\u0026#34; v-if=\u0026#34;todos.length \u0026gt; 0\u0026#34;\u0026gt; 或者\n1 \u0026lt;footer v-show=\u0026#34;todos.length\u0026#34; class=\u0026#34;footer\u0026#34;\u0026gt; 总结 通过本文的介绍，我们学习了如何使用 Vue.js 框架构建一个完整的 TodoMVC 应用。我们涵盖了从项目搭建、数据管理、事件处理到视图渲染的各个方面。希望这篇文章能帮助你更好地理解 Vue.js 的核心概念和实战技巧。如果你对 Vue.js 有更深入的兴趣，建议继续学习官方文档和相关课程，提升你的前端开发技能。\n我的代码仓库地址\n","date":"2026-01-05T18:12:04+08:00","permalink":"http://tech-ox.com/p/vue.js-%E5%AE%9E%E6%88%98%E6%9E%84%E5%BB%BA-todomvc-%E5%BA%94%E7%94%A8/","title":"vue.js 实战：构建 TodoMVC 应用"},{"content":"题目 128. 最长连续序列\n官方题解\n方法一：哈希表 使用哈希表存储数组中的元素，然后对于每个元素，检查其前驱元素是否存在，以此来找到连续序列的起点，并计算序列长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_set\u0026lt;int\u0026gt; num_set; for (auto num : nums) { num_set.insert(num); } int res = 0; for (auto num : num_set) { if (!num_set.count(num - 1)) { int cur = num; int len = 1; while (num_set.count(cur + 1)) { len ++; cur ++; } res = max(res, len); } } return res; } }; ","date":"2026-01-05T13:17:12+08:00","permalink":"http://tech-ox.com/p/128.-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/","title":"128. 最长连续序列"},{"content":"题目 64. 最小路径和\n官方题解\n方法一：动态规划 使用二维数组 f[i][j] 表示从起点到位置 (i, j) 的最小路径和。状态转移方程为：\nf[0][0] = grid[0][0] f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j]（当 i \u0026gt; 0 且 j \u0026gt; 0 时） 边界情况：第一行和第一列只能从左或上累加。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(m, vector\u0026lt;int\u0026gt;(n)); for (int i = 0; i \u0026lt; m; i ++) for(int j = 0; j \u0026lt; n; j ++) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[0][0] = grid[0][0]; } else if (i == 0) { f[i][j] = f[i][j - 1] + grid[i][j]; } else if (j == 0) { f[i][j] = f[i - 1][j] + grid[i][j]; } else { f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; } } return f[m - 1][n - 1]; } }; 时间复杂度：O(m _ n)，空间复杂度：O(m _ n)。\n方法二：动态规划（空间优化） 由于每次计算只依赖上一行和当前行，可以用一维数组 f[j] 表示当前行的最小路径和。\n初始化第一行时，f[j] 累加左边值。 后续行：f[j] 先保存上一行的值，然后更新为 min(f[j], f[j-1]) + grid[i][j]。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = grid[0].size(); vector\u0026lt;int\u0026gt; f(n); for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { f[0] = grid[0][0]; } else if (i == 0) { f[j] = f[j - 1] + grid[i][j]; } else if (j == 0) { f[j] = f[j] + grid[i][j]; // f[j] 为上一行的 f[j] } else { f[j] = min(f[j], f[j - 1]) + grid[i][j]; // f[j] 为上一行的 f[j] } } } return f[n - 1]; } }; 时间复杂度：O(m * n)，空间复杂度：O(n)。\n","date":"2026-01-05T12:39:13+08:00","permalink":"http://tech-ox.com/p/64.-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","title":"64. 最小路径和"},{"content":"题目 32. 最长有效括号 官方题解\n方法一：栈 理解墙的概念，先向栈中加入一个-1的墙，每次匹配到右括号 ( 就弹栈一次，把左括号 ) 给弹出去，然后判断栈是否为空，因为有个 -1 的墙，如果栈空了，说明是没有匹配的左括号，就向栈中放新的墙来替代-1，这个墙永远在栈底这个位置，如果有新的墙产生，会先把这个栈底墙弹出去，有点设计的过于巧妙了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int longestValidParentheses(std::string s) { int res = 0; stack\u0026lt;int\u0026gt; stk; stk.push(-1); for (int i = 0; i \u0026lt; s.length(); ++i) { if (s[i] == \u0026#39;(\u0026#39;) { stk.push(i); } else { stk.pop(); if (stk.empty()) { stk.push(i); } else { res = max(res, i - stk.top()); } } } return res; } }; 方法二：动态规划 有点过于复杂了\ns[i] = \u0026lsquo;)\u0026rsquo; 且 s[i-1] = \u0026lsquo;(\u0026rsquo; 时，dp[i] = dp[i-2] + 2 s[i] = \u0026lsquo;)\u0026rsquo; 且 s[i-1] = \u0026lsquo;)\u0026rsquo; 时，若 s[i-dp[i-1]-1] = \u0026lsquo;(\u0026rsquo;，则 dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2 还要注意俩个边界条件要排除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int longestValidParentheses(string s) { int maxans = 0, n = s.length(); vector\u0026lt;int\u0026gt; dp(n, 0); for (int i = 1; i \u0026lt; n; i++) { if (s[i] == \u0026#39;)\u0026#39;) { if (s[i - 1] == \u0026#39;(\u0026#39;) { dp[i] = (i \u0026gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] \u0026gt; 0 \u0026amp;\u0026amp; s[i - dp[i - 1] - 1] == \u0026#39;(\u0026#39;) { dp[i] = dp[i - 1] + ((i - dp[i - 1]) \u0026gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = max(maxans, dp[i]); } } return maxans; } }; ","date":"2026-01-05T10:39:13+08:00","permalink":"http://tech-ox.com/p/32.-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","title":"32. 最长有效括号"},{"content":"题目 538. 把二叉搜索树转换为累加树 官方题解\n方法一：反向中序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int sum; TreeNode* convertBST(TreeNode* root) { if (root != nullptr) { convertBST(root-\u0026gt;right); sum += root-\u0026gt;val; root-\u0026gt;val = sum; convertBST(root-\u0026gt;left); } return root; } }; ","date":"2026-01-05T09:24:31+08:00","permalink":"http://tech-ox.com/p/538.-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/","title":"538. 把二叉搜索树转换为累加树"},{"content":"题目 338. 比特位计数 官方题解\n方法一：逐位计数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int countB(int i) { int cnt = 0; while (i) { cnt += i \u0026amp; 1; i = i \u0026gt;\u0026gt; 1; } return cnt; } vector\u0026lt;int\u0026gt; countBits(int n) { vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt;= n; i ++) { res.push_back(countB(i)); } return res; } }; 方法二：动态规划——最低有效位 $$ f[i] = f[i \u003e\u003e 1] + (i \\\u0026 1) $$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: vector\u0026lt;int\u0026gt; countBits(int n) { vector\u0026lt;int\u0026gt; res; res.push_back(0); for (int i = 1; i \u0026lt;= n; i ++) { res.push_back(res[i \u0026gt;\u0026gt; 1] + (i \u0026amp; 1)); } return res; } }; 方法三：动态规划——最高有效位 $$ (i \u0026 (i - 1)) == 0 f[i] = f[i - highBit] + 1 $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: vector\u0026lt;int\u0026gt; countBits(int n) { vector\u0026lt;int\u0026gt; bits(n + 1); int highBit = 0; for (int i = 1; i \u0026lt;= n; i++) { if ((i \u0026amp; (i - 1)) == 0) { highBit = i; } bits[i] = bits[i - highBit] + 1; } return bits; } }; ","date":"2026-01-05T09:05:34+08:00","permalink":"http://tech-ox.com/p/338.-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/","title":"338. 比特位计数"},{"content":"题目 240. 搜索二维矩阵 II 官方题解\n方法一：从右上角开始搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { if (matrix.size() == 0 || matrix[0].size() == 0) return false; int rows = matrix.size(), columns = matrix[0].size(); // 从右上角(0, columns)-\u0026gt;(rows, 0) // 如果小于就target就下移，大于左移 int x = 0, y = columns - 1; while (x \u0026lt; rows \u0026amp;\u0026amp; y \u0026gt;= 0) { if (matrix[x][y] \u0026lt; target) { x ++; } else if (matrix[x][y] \u0026gt; target) { y --; } else { return true; } } return false; } }; 时间复杂度\nO(m + n)，m 和 n 分别是矩阵的行数和列数。\n方法二：爆搜 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target, int x, int y) { if (x \u0026gt;= matrix.size() || y \u0026gt;= matrix[0].size()) { return false; } if (matrix[x][y] == target) { return true; } else if (matrix[x][y] \u0026lt; target) { return dfs(matrix, target, x + 1, y) || dfs(matrix, target, x, y +1); } else { return false; } } bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { return dfs(matrix, target, 0, 0); } }; 时间复杂度\nO(2^(m+n))，m 和 n 分别是矩阵的行数和列数。\n117 / 130 个通过的测试用例\n","date":"2026-01-04T14:24:40+08:00","permalink":"http://tech-ox.com/p/240.-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/","title":"240. 搜索二维矩阵 II"},{"content":"题目 85. 最大矩形 官方题解\n刚开始想了一个暴力的解法，但是理解错误题目意思了，是矩形不是正方形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool isTrue(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix, int i, int j, int size) { for (int x = i; x \u0026lt; i + size; x ++) { for (int y = j; y \u0026lt; j + size; y ++) { if (matrix[x][y] == \u0026#39;0\u0026#39;) return false; } } return true; } int maximalSquare(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { int max_size = min(matrix.size(), matrix[0].size()); for (int i = max_size; i \u0026gt; 0; i --) { for (int j = 0; j + i \u0026lt;= matrix.size(); j ++) { for (int k = 0; k + i \u0026lt;= matrix[0].size(); k ++) { // 判断是否 if (isTrue(matrix, j, k, i)) return i * i; } } } return 0; } }; 时间复杂度\nO((mn)^2)，m 和 n 分别是矩阵的行数和列数。\n实际上是原题 221. 最大正方形\n动态规划写法\n$$ dp(i,j)=\\min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1 $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int maximalSquare(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) { return 0; } int maxSide = 0; int rows = matrix.size(), columns = matrix[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(rows, vector\u0026lt;int\u0026gt;(columns)); for (int i = 0; i \u0026lt; rows; i ++) { for (int j = 0; j \u0026lt; columns; j ++) { if (matrix[i][j] == \u0026#39;1\u0026#39;) { if (i == 0 || j == 0) { dp[i][j] = 1; } else { dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; } maxSide = max(maxSide, dp[i][j]); } } } return maxSide * maxSide; } }; 回到原题 暴力枚举\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: bool isTrue(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix, int i, int j, int x, int y) { // 判断 (i, j) (x, y) 矩形 for (int k = i; k \u0026lt;= x; k ++) { for (int l = j; l \u0026lt;= y; l ++) { if (matrix[k][l] == \u0026#39;0\u0026#39;) { return false; } } } return true; } int maximalRectangle(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) return 0; int rows = matrix.size(), columns = matrix[0].size(); int maxSize = 0; for (int i = 0; i \u0026lt; rows; i ++) for (int j = 0; j \u0026lt; columns; j ++) if (matrix[i][j] == \u0026#39;1\u0026#39;) { // 枚举右下角坐标 for (int x = i; x \u0026lt; rows; x ++) { for (int y = j; y \u0026lt; columns; y ++ ) { if (isTrue(matrix, i, j, x, y)) { maxSize = max(maxSize, (x - i + 1) * (y - j + 1)); } } } } return maxSize; } }; 时间复杂度\nO((mn)^3)，m 和 n 分别是矩阵的行数和列数。\n70/75 TLE\n暴力优化 我们首先计算出矩阵的每个元素的左边连续 1 的数量，使用二维数组 left 记录，其中 left[i][j] 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: int maximalRectangle(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) return 0; int rows = matrix.size(), columns = matrix[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; left(rows, vector\u0026lt;int\u0026gt;(columns)); for (int i = 0; i \u0026lt; rows; i ++) { for (int j = 0; j \u0026lt; columns; j ++) { // 判断(i, j) 左侧有多少个连续的1 if (matrix[i][j] == \u0026#39;1\u0026#39;) { left[i][j] = (j == 0 ? 1 : left[i][j - 1] + 1); } } } int ret = 0; for (int i = 0; i \u0026lt; rows; i ++) { for (int j = 0; j \u0026lt; columns; j ++) { if (matrix[i][j] == \u0026#39;0\u0026#39;) { continue; } int width = left[i][j]; int area = width; for (int k = i - 1; k \u0026gt;= 0; k --) { width = min(width, left[k][j]); area = max(area, width * (i - k + 1)); } ret = max(ret, area); } } return ret; } }; 还是动态规划，提示标签里有单调栈，先放一放\n","date":"2026-01-04T10:37:02+08:00","permalink":"http://tech-ox.com/p/85.-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","title":"85. 最大矩形"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://tech-ox.com/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_9e6bcf9cfe9a9448.jpg","permalink":"http://tech-ox.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://tech-ox.com/p/math-typesetting/","title":"Math Typesetting"}]